# -*- coding: utf-8 -*-
"""diamond_algo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fCzU6wibx4hakIGT6gsXwQwFlpIidgFa

## 고유 diamond 구하기
"""

import pickle
from collections import Counter
from tqdm import tqdm
import matplotlib.pyplot as plt
from collections import defaultdict

with open('2021_10_31.pkl', 'rb') as f:
  datas = pickle.load(f)

datas[0].keys()

# 4 chords
out = []
for data in datas:
  if 'ost' in data['Genre']:
    chord = data['New_chord']
  else:
    continue
  chord = data['New_chord']
  chord1 = chord[:-3]
  chord2 = chord[1:-2]
  chord3 = chord[2:-1]
  chord4 = chord[3:]
  for c1, c2, c3, c4 in zip(chord1, chord2, chord3, chord4):
    out.append('_'.join([c1,c2,c3,c4]))

C_out = Counter(out)
sortedC = sorted(C_out.items(), key=lambda x:x[1], reverse=True)
x = [i[0] for i in sortedC]
y = [i[1] for i in sortedC]
print('코드 개수: ', len(C_out))

diamonds = [] # 
def diamondappend(chord, chordnum):
  global diamonds
  for n, (dia, num) in enumerate(diamonds):
    if dia.find(chord) != -1:
      diamonds[n][1] += chordnum
      return True # 있는 diamond 중 하나다!
  diamonds.append([chord+'_'+chord, chordnum])
  return False # 없는 diamond라 추가했다.

for chord, chordnum in tqdm(C_out.items()):
  diamondappend(chord, chordnum)

print('diamond 종류:', len(diamonds))
sorted_dia = sorted(diamonds, key=lambda x:x[1], reverse=True)

sorted_dia[:20]

new_dias = [['_'.join(chord.split('_')[:4]), chordnum] for chord, chordnum in sorted_dia]
x = [chord for chord, chordnum in new_dias]
y = [chordnum for chord, chordnum in new_dias]

fig, axe = plt.subplots(figsize=(20,5))
# plt.yscale('log')
plt.title('Diamond distribution')
plt.plot(x[:20], y[:20])
plt.setp(axe.get_xticklabels(), rotation=45, ha="right",
          rotation_mode="anchor")
plt.show()

"""## 노래별로 다이아몬드 개수 분석"""

# 노래의 코드 전체를 받으면 diamond 목록으로 출력
# 전제: diamonds 데이터 셋
def diamondsearch(song_chords):
  normalizer = len(song_chords)-3
  out = defaultdict(int) # chord, chordnum
  temp = []
  chord1 = song_chords[:-3]
  chord2 = song_chords[1:-2]
  chord3 = song_chords[2:-1]
  chord4 = song_chords[3:]
  for c1, c2, c3, c4 in zip(chord1, chord2, chord3, chord4):
    temp.append('_'.join([c1,c2,c3,c4]))
  C_temp = Counter(temp)
  for chordset, chordnum in C_temp.items():
    for dia, dianum in diamonds:
      if dia.find(chordset) != -1:
        out[dia] += chordnum / normalizer
        out[dia] = round(out[dia], 3)
        break
  # newout = [['_'.join(chord.split('_')[:4]), chordnum] for chord, chordnum in out.items()]
  newout = [['_'.join(chord.split('_')[:]), chordnum] for chord, chordnum in out.items()]
  return newout

index = 893
print('노래명: ', datas[index]['Songname'], '\n아티스트:', datas[index]['Artist'], '\n')
_data = diamondsearch(datas[index]['New_chord'])
_data = sorted(_data, key=lambda x:x[1], reverse=True)
for i in _data:
  print(i)

fig, axe = plt.subplots(figsize=(20,5))
# plt.yscale('log')
plt.title('Songname: '+datas[index]['Songname'])
plt.plot([chord for chord, chordnum in _data], [chordnum for chord, chordnum in _data])
plt.setp(axe.get_xticklabels(), rotation=45, ha="right",
          rotation_mode="anchor")
plt.show()



"""## 전체 통계"""

outdict = defaultdict(int)
for data in datas:
  dias = diamondsearch(data['New_chord'])
  for dia, num in dias:
    outdict[dia] += num
_data = sorted(outdict.items(), key=lambda x:x[1], reverse=True)

fig, axe = plt.subplots(figsize=(20,5))
# plt.yscale('log')
plt.title('Full data normalized sum graph')
plt.plot([chord for chord, chordnum in _data][:30], [chordnum for chord, chordnum in _data][:30])
plt.setp(axe.get_xticklabels(), rotation=45, ha="right",
          rotation_mode="anchor")
plt.show()

"""피클
 변환
"""

def diamondsearch_full(song_chords):
  normalizer = len(song_chords)-3
  out = defaultdict(int) # chord, chordnum
  temp = []
  chord1 = song_chords[:-3]
  chord2 = song_chords[1:-2]
  chord3 = song_chords[2:-1]
  chord4 = song_chords[3:]
  for c1, c2, c3, c4 in zip(chord1, chord2, chord3, chord4):
    temp.append('_'.join([c1,c2,c3,c4]))
  C_temp = Counter(temp)
  for chordset, chordnum in C_temp.items():
    for dia, dianum in diamonds:
      if dia.find(chordset) != -1:
        out[dia] += chordnum / normalizer
        out[dia] = round(out[dia], 3)
        break
  return out.items()

diaout = defaultdict(list)
for data in tqdm(datas):
  dias = diamondsearch_full(data['New_chord'])
  title = data['Songname']
  for dia, num in dias:
    diaout[title].append([dia,num])

with open('./chord_dia_11_14.pkl', 'wb') as f:
  pickle.dump(diaout, f)

with open('./diamonds.pkl', 'wb') as f:
  pickle.dump(diamonds, f)

with open('./diamonts_norm.pkl', 'wb') as f:
  pickle.dump(_data, f)

